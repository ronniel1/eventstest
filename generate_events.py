import yaml
import logging
import argparse
import jinja2
from collections import OrderedDict


def generate_go(events):
      # generate single dict of all properties from all events
      return EVENT_TEMPLATE.render(
          GeneratorUtils=GeneratorUtils(),
          generator=EventsDefinitionGenerator(events=events))

class GeneratorUtils(object):

    @staticmethod
    def cap(s):
        if len(s) == 0:
            return s
        return s[0].upper() + s[1:]

    @staticmethod
    def camel_case(value):
        parts = value.split('_')
        return parts[0] + ''.join(GeneratorUtils.cap(part) for part in parts[1:])

    @staticmethod
    def pascal_case(value):
        return ''.join(GeneratorUtils.cap(part) for part in value.split('_'))

    @staticmethod
    def to_go_type(var_type):
        if var_type == 'integer':
            return 'int'
        elif var_type in ["string"]:
            return 'string'
        else:
            return var_type

    @staticmethod
    def event_entity_type(value):
        return "entity" + GeneratorUtils.pascal_case(value)


# NOQA
EVENT_TEMPLATE = jinja2.Template('''// Code generated by from events definition in swagger; DO NOT EDIT.
package event

import (
    eventslib "github.com/ronniel1/eventstest/events"
    "strings"
)

{% for event in generator.events -%}
{% set egen = generator.get_event_generator(event) %}
//
// Event {{event['name']}}
//

{% set eventName = egen.event_class() -%}
type {{eventName}} struct {
    eventslib.EventBase
{%- for p, t in event.properties.items() %}
    {{GeneratorUtils.pascal_case(p)}} {{GeneratorUtils.to_go_type(t)}}
{%- endfor %}
}

func New{{eventName}}(
{%- for p, t in event.properties.items() %}
    {{GeneratorUtils.camel_case(p)}} {{GeneratorUtils.to_go_type(t)}},
{%- endfor %}
) *{{eventName}} {
    return &{{eventName}} {
		EventBase: eventslib.EventBase {
			Format:   "{{event.format}}",
			Id:       "{{event.id}}",
			Type:     eventslib.EventType{{GeneratorUtils.pascal_case(event.type)}},
			Severity: eventslib.EventSeverity{{GeneratorUtils.pascal_case(event.severity)}},
		},
{%- for p, t in event.properties.items() %}
        {{GeneratorUtils.pascal_case(p)}}: {{GeneratorUtils.camel_case(p)}},
{%- endfor %}
    }
}

func (e *{{eventName}}) GetEventBase() *eventslib.EventBase {
    return &e.EventBase
}

func (e *{{eventName}}) FormatMessage() string {
    r := strings.NewReplacer(
{%- for p, t in event['properties'].items() %}
    "{{'{{'}} {{p}} {{'}}'}}", e.{{GeneratorUtils.pascal_case(p)}},
{%- endfor %}
                  )
          return r.Replace(e.EventBase.Format)
}
{%- endfor %}

''')


class EventsDefinitionGenerator(object):
    def __init__(self, events):
        self.events = events

    INT_TYPES = ["integer", "int", "int64", "int32"]
    UINT_TYPES = ["uint64", "uint32"]

    @classmethod
    def get_event_generator(cls, event):
        return EventGenerator(event)


class EventGenerator(object):
    def __init__(self, event):
        self.event = event

    def ctor_name(self):
        return "New" + self.event_class()

    def ctor_args(self):
        args = []
        for arg, _ in self.event.properties.iteritems():
            args.append(GeneratorUtils.camel_case(arg) + " " + GeneratorUtils.pascal_case(arg))
        return ", ".join(args)

    def event_class(self):
        return GeneratorUtils.pascal_case(self.event.name) + "Event"

    def event_type(self):
        return "Type" + GeneratorUtils.pascal_case(self.event.name)

    def event_severity(self):
        if self.event.severity.lower() == "debug":
            return "SeverityDebug"
        if self.event.severity.lower() == "info":
            return "SeverityInfo"
        if self.event.severity.lower() == "warning":
            return "SeverityWarning"
        if self.event.severity.lower() == "error":
            return "SeverityError"
        if self.event.severity.lower() == "critical":
            return "SeverityCritical"


class EventDef:
    def __init__(self, name, format, id, event_type, severity, properties):
        self.name = name
        self.format = format
        self.id = id
        self.type = event_type
        self.severity = severity
        self.properties = properties


def parse(swagger_path):
    def dict_ctor(loader, node):
        return OrderedDict(loader.construct_pairs(node))

    # setup yaml to use OrderedDict. This is important so that the generated Golang code keeps
    # the order of the arguments to the event submission functions.
    yaml.Loader.add_constructor(yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, dict_ctor)
    with open(swagger_path, "r") as spec_file:
        spec = yaml.load(spec_file, Loader=yaml.Loader)

    if spec is None:
        raise ValueError("Invalid spec file")

    events_spec = spec.get("x-events")
    if events_spec is None:
        logging.error("Cannot find events in %s", swagger_path)
        raise ValueError(
            "Invalid spec file, missing %r section" % EVENT_SECTION
        )

    events = []
    print(events_spec)
    for e in events_spec:
        ne = EventDef(name=e['name'], format=e['message'], id=e['id'], event_type=e['event_type'], severity=e['severity'], properties=e['properties'])
        events.append(ne)

    g = generate_go(events)
    #import ipdb; ipdb.set_trace()
    return g




def main():
    """Tool entry point - read parameters from users and start tool."""
    parser = argparse.ArgumentParser(
        description='Generate events definitions based on specifications.'
    )
    parser.add_argument('source', type=str, help='swagger source path')
    parser.add_argument('dest', type=str, help='destination file path')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='set log level to debug')
    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    g = parse(swagger_path=args.source)
    with open(args.dest, "w+") as fout:
        fout.write(g)


if __name__ == '__main__':
    main()

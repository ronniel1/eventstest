import yaml
import logging
import argparse
import jinja2
from collections import OrderedDict


def generate_go(events):
      # generate single dict of all properties from all events
      return EVENT_TEMPLATE.render(
          GeneratorUtils=GeneratorUtils(),
          generator=(EventGenerator(e) for e in events))
      #generator=EventsDefinitionGenerator(events=events))


class GeneratorUtils(object):

    @staticmethod
    def base_event(event):
        if event.type == "cluster":
            return "ClusterBaseEvent"
        else:
            return "HostBaseEvent"

    @staticmethod
    def cap(s):
        if len(s) == 0:
            return s
        return s[0].upper() + s[1:]

    @staticmethod
    def camel_case(value):
        parts = value.split('_')
        return parts[0] + ''.join(GeneratorUtils.cap(part) for part in parts[1:])

    @staticmethod
    def pascal_case(value):
        return ''.join(GeneratorUtils.cap(part) for part in value.split('_'))

    @staticmethod
    def go_type(var_type):
        if var_type == 'integer':
            return 'int'
        elif var_type in ["string"]:
            return 'string'
        else:
            return var_type

    @staticmethod
    def type_to_string(var_type, var_name):
        if var_type == 'string':
            return var_name
        else:
            return 'fmt.Sprint({})'.format(var_name)


# NOQA
EVENT_TEMPLATE = jinja2.Template('''// Code generated by from events definition in swagger; DO NOT EDIT.
package event

import (
    "fmt"
    "strings"
    eventslib "github.com/ronniel1/eventstest/events"
)

{% for event in generator -%}

//
// Event {{event['name']}}
//
{% set eventName = event.event_class() -%}
{% set baseEvent = GeneratorUtils.base_event(event) -%}
type {{eventName}} struct {
    eventslib.{{baseEvent}}
{%- for p, t in event.properties.items() %}
    {{GeneratorUtils.pascal_case(p)}} {{GeneratorUtils.go_type(t)}}
{%- endfor %}
}

func New{{eventName}}(
{%- for p, t in event.properties.items() %}
    {{GeneratorUtils.camel_case(p)}} {{GeneratorUtils.go_type(t)}},
{%- endfor %}
) *{{eventName}} {
    return &{{eventName}} {
		{{baseEvent}}: eventslib.{{baseEvent}} {
			Format:   "{{event.format}}",
			Id:       "{{event.id}}",
			Severity: eventslib.EventSeverity{{GeneratorUtils.pascal_case(event.severity)}},
		},
{%- for p, t in event.properties.items() %}
        {{GeneratorUtils.pascal_case(p)}}: {{GeneratorUtils.camel_case(p)}},
{%- endfor %}
    }
}

func (e *{{eventName}}) GetBaseEvent() *eventslib.{{baseEvent}} {
    return &e.{{baseEvent}}
}

func (e *{{eventName}}) FormatMessage() string {
    r := strings.NewReplacer(
{%- for p, t in event['properties'].items() %}
    "{{'{'}}{{p}}{{'}'}}", fmt.Sprint(e.{{GeneratorUtils.pascal_case(p)}}),
{%- endfor %}
                  )
          return r.Replace(e.{{baseEvent}}.Format)
}

{% endfor -%}

''')


class EventsDefinitionGenerator(object):
    def __init__(self, events):
        self.events = events

    @classmethod
    def get_event_generator(cls, event):
        return EventGenerator(event)


class EventGenerator(object):
    def __init__(self, event):
        self.event = event

    def __getattr__(self, attr):
        #import ipdb; ipdb.set_trace()
        if attr in self.__dict__:
            return getattr(self, attr)
        else:
            return getattr(self.event, attr)

    def ctor_name(self):
        return "New" + self.event_class()

    def ctor_args(self):
        args = []
        for arg, _ in self.event.properties.iteritems():
            args.append(GeneratorUtils.camel_case(arg) + " " + GeneratorUtils.pascal_case(arg))
        return ", ".join(args)

    def event_class(self):
        return GeneratorUtils.pascal_case(self.event.name) + "Event"

    def event_type(self):
        return "Type" + GeneratorUtils.pascal_case(self.event.name)

    def event_severity(self):
        if self.event.severity.lower() == "debug":
            return "EventSeverityDebug"
        if self.event.severity.lower() == "info":
            return "EventSeverityInfo"
        if self.event.severity.lower() == "warning":
            return "EventSeverityWarning"
        if self.event.severity.lower() == "error":
            return "EventSeverityError"
        if self.event.severity.lower() == "critical":
            return "EventSeverityCritical"


class EventDef:
    def __init__(self, name, format, id, event_type, severity, properties):
        self.name = name
        self.format = format
        self.id = id
        self.type = event_type
        self.severity = severity
        self.properties = properties


def parse(swagger_path):
    def dict_ctor(loader, node):
        return OrderedDict(loader.construct_pairs(node))

    # setup yaml to use OrderedDict. This is important so that the generated Golang code keeps
    # the order of the arguments to the event submission functions.
    yaml.Loader.add_constructor(yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, dict_ctor)
    with open(swagger_path, "r") as spec_file:
        spec = yaml.load(spec_file, Loader=yaml.Loader)

    if spec is None:
        raise ValueError("Invalid spec file")

    events_spec = spec.get("x-events")
    if events_spec is None:
        logging.error("Cannot find events in %s", swagger_path)
        raise ValueError(
            "Invalid spec file, missing %r section" % EVENT_SECTION
        )

    events = []
    print(events_spec)
    for e in events_spec:
        ne = EventDef(name=e['name'], format=e['message'], id=e['id'], event_type=e['event_type'], severity=e['severity'], properties=e['properties'])
        events.append(ne)

    g = generate_go(events)
    return g




def main():
    """Tool entry point - read parameters from users and start tool."""
    parser = argparse.ArgumentParser(
        description='Generate events definitions based on specifications.'
    )
    parser.add_argument('source', type=str, help='swagger source path')
    parser.add_argument('dest', type=str, help='destination file path')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='set log level to debug')
    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    g = parse(swagger_path=args.source)
    with open(args.dest, "w+") as fout:
        fout.write(g)


if __name__ == '__main__':
    main()
